from simFunc import *
from simCls import *

#  main procedure
newUE(20)
for currTime in range(p.simTime):

    if not currTime % 1000:
        newUE(np.random.poisson(3))  # create the UE

    if not currTime % p.csaPeriod - p.eMBMS_triggerTime:  # a new CSA Period
        p.MSA = p.cost  # reset the amount of resource for each eMBMS session

    # ue changes the site
    if not currTime % 50:
        for ue in p.UeList:
            changeSite(ue)

    # a new video frame is sent (25FPS video,i.e., 1 video frame per 40ms)
    if not currTime % 40 and currTime:
        for i in range(1, p.numSrv):  # create the event of RT packets arriving
            buildEvent(i, currTime)

    while p.eventList.get(currTime):  # there are packets arrived at this moment
        pktCret(p.eventList.pop(currTime))

    modfPara()  # modify the scheduler's parameter

    # calculate resource allocation priority for each UE
    for i in range(len(p.UeList)):
        if p.UeList[i].buffLen:  # to assign the priority to UE having transmission requirement
            p.priority[i] = ExpPf(p.UeList[i])

    # assign resource to eMBMS
    if len(p.sf2eMBMS) and currTime == p.sf2eMBMS[0]:  # the time is reserved to eMBMS
        resourceAllocation(1)
        p.sf2eMBMS.remove(p.sf2eMBMS[0])

    # assign resource to unicast UE
    else:
        resourceAllocation(0)
        if not p.numRtPkt + p.numNrtPkt and not p.decFlag:  # if there is no data needs to transmit
            p.decFlag = True
            p.time_unusedRB = currTime % 5120

    addDelay()  # add the delay time of each packet

    calRou(currTime)  # calculate the rou of the time

    # calculate the equation (10)
    if p.eMBMS_triggerTime != -1 and not currTime % 5120 - p.eMBMS_triggerTime:
        calAvgDifRou(0)  # calculate the equation (10)
        if not p.incFlag:  # if doesn't need to modify the resources scheme
            modResourceAlloSchemeforeMBMS(0)
            allocSf2eMBMS(currTime)

    # changing the streaming quality of unicast UE
    if not currTime % 3000 and currTime:
        for ue in p.UeList:
            if ue.numInvPkt == 0 and ue.srvQ < 7 and not ue.srv in p.setEmbmsSess:  # improve the streaming quality
                ue.srvQ += 1
            ue.numInvPkt = ue.numPkt = 0

    # trigger eMBMS if there any UE's IPR exceeds its tolerate
    if not currTime % 2000 and currTime:
        for ue in p.UeList:
            if ue.numInvPkt / (ue.numPkt + 1) >= p.Tolerate[ue.srv]:
                p.incFlag = True
                if ue.srvQ > 0:
                    ue.srvQ -= 1
                if p.eMBMS_triggerTime == -1:
                    p.eMBMS_triggerTime = currTime % 5120

    if p.unusedRbHappend:  # if unused RB event is happened
        calAvgDifRou(p.time_unusedRB)  # calculate the equation (13)

    if not currTime % 5120 - p.eMBMS_triggerTime and p.incFlag:  # increasing the resource for eMBMS
        modResourceAlloSchemeforeMBMS(0.01)
        allocSf2eMBMS(currTime)
    elif not currTime % 5120 - p.eMBMS_triggerTime and p.decFlag:  # decreasing the resource for eMBMS
        modResourceAlloSchemeforeMBMS(-0.01)
        allocSf2eMBMS(currTime)

UeThroughput = 0
for ue in p.UeList:
    UeThroughput += ue.throughput
print("ADR:", UeThroughput / p.numUE)
print("IPR:", p.numInvPkt / p.pktId)
print("RUR:", p.unusedRB / (p.NumRbsPerSf*p.simTime))
print("RE:", p.setEmbmsSess/ (p.NumRbsPerSf*p.simTime))